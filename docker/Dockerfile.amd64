# Optimized Dockerfile for ElasticDash-API AWS deployment
# Multi-stage build to reduce image size and improve build performance

# Stage 1: Node.js dependencies
FROM node:18-slim as node-builder

WORKDIR /app

# Install build dependencies for native modules
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    python3 \
    make \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Copy package files first for better layer caching
COPY package*.json ./
RUN npm install --no-audit --no-fund && \
    npm cache clean --force

# Stage 2: Final runtime image
FROM node:18-slim

# Build arguments for environment configuration
ARG BUILD_ENV=dev

# Define non-root user early with explicit paths
ARG UID=1000
ARG GID=1000
ENV USER=elasticdash
ENV HOME=/home/elasticdash

# Install all system dependencies in one layer
RUN apt-get update && apt-get install -y --no-install-recommends \
    # Database and system libraries
    libpq-dev \
    # Image processing dependencies for canvas and jimp
    libcairo2-dev \
    libpango1.0-dev \
    libjpeg-dev \
    libgif-dev \
    librsvg2-dev \
    # GraphicsMagick dependencies
    libgraphicsmagick1-dev \
    libgraphicsmagick-q16-3 \
    # Process management
    dumb-init \
    # Health check utilities
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get autoremove -y \
    && apt-get autoclean

# Create non-root user with specific UID/GID for better K8s compatibility
RUN groupadd -g $GID $USER 2>/dev/null || groupmod -n $USER $(getent group $GID | cut -d: -f1) && \
    useradd -u $UID -g $GID -m -s /bin/bash $USER 2>/dev/null || usermod -l $USER -d /home/$USER -m $(getent passwd $UID | cut -d: -f1)

# Set working directory
WORKDIR /app

# Copy Node.js dependencies from builder stage
COPY --from=node-builder /app/node_modules ./node_modules
COPY --from=node-builder /app/package*.json ./

# Copy application code with proper ownership
COPY --chown=$USER:$USER . .

# Copy appropriate .env file based on BUILD_ENV
RUN if [ "$BUILD_ENV" = "prod" ] && [ -f ".env.prod" ]; then \
        cp .env.prod .env && echo "Using production .env file"; \
    elif [ "$BUILD_ENV" = "staging" ] && [ -f ".env.staging" ]; then \
        cp .env.staging .env && echo "Using staging .env file"; \
    elif [ -f ".env" ]; then \
        echo "Using default .env file"; \
    else \
        echo "ERROR: No .env file found for BUILD_ENV=$BUILD_ENV"; \
        exit 1; \
    fi

# Create app-specific directories and fix all permissions
RUN mkdir -p logs temp && \
    chown -R $USER:$USER /app && \
    chmod +x docker/docker-entrypoint.sh 2>/dev/null || true

# Set environment variables
ENV NODE_ENV=production \
    # Performance optimizations
    NODE_OPTIONS="--max-old-space-size=2048" \
    # Application port
    PORT=3000

# Switch to non-root user for runtime
USER $USER

# Expose port
EXPOSE 3000

# Improved health check with better error handling
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:3000/api/health || curl -f http://localhost:3000/ || exit 1

# Use dumb-init as PID 1 for proper signal handling
ENTRYPOINT ["dumb-init", "--"]

# Start application with proper babel transpilation
CMD ["npm", "start"]