import { query, formatTimestamp, sanitizeDbError } from '../../postgres.js';
import { insertMessage } from './messageDAO.js';

/**
 * Data Access Object for Chat Plans
 * Handles storage and retrieval of execution plans generated by the planner
 */

/**
 * Create a new chat plan
 * @param {number} conversationId - Conversation ID
 * @param {number} userId - User ID
 * @param {number} userMessageId - ID of user message that triggered plan (optional)
 * @param {Object} planJson - Full plan object from planner
 * @param {string} intentType - Type of intent (FETCH, MODIFY, etc.)
 * @returns {Promise<Object>} Created plan with id
 */
export async function createPlan({
    conversationId,
    userId,
    userMessageId,
    planJson,
    intentType,
}) {
    try {
        // Create the plan first
        const result = await query(
            `INSERT INTO ChatPlans
             (conversation_id, user_message_id, plan_json, intent_type, status, needs_approval, created_by, updated_by)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
             RETURNING id, conversation_id, user_message_id, plan_json, intent_type, status,
                       needs_approval, created_at, created_by`,
            [
                conversationId,
                userMessageId || null,
                JSON.stringify(planJson),
                intentType || 'UNKNOWN',
                'pending',
                true,
                userId,
                userId,
            ]
        );

        const plan = result.rows[0];

        // Create a corresponding message in the conversation
        const executionSteps = planJson.execution_plan || [];
        const planSummary = `Created execution plan with ${executionSteps.length} step${executionSteps.length !== 1 ? 's' : ''}`;

        await insertMessage({
            conversationId,
            userId,
            customerUserId: null,
            role: 'assistant',
            content: planSummary,
            messageType: 'plan',
            metadata: {
                planId: plan.id,
                intentType: intentType || 'UNKNOWN',
                stepCount: executionSteps.length,
                needsApproval: true
            }
        });

        return plan;
    } catch (error) {
        console.error('Error creating plan:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Get plan by ID
 * @param {number} planId - Plan ID
 * @param {number} userId - User ID for access control
 * @returns {Promise<Object|null>} Plan or null
 */
export async function getPlanById(planId, userId) {
    try {
        const result = await query(
            `SELECT p.id, p.conversation_id, p.user_message_id, p.plan_json, p.intent_type, 
                    p.status, p.needs_approval, p.approved_at, p.approved_by, p.rejected_at, 
                    p.rejected_by, p.rejection_reason, p.created_at, p.updated_at
             FROM ChatPlans p
             JOIN Conversations c ON p.conversation_id = c.id
             WHERE p.id = $1 AND c.user_id = $2 AND p.deleted = FALSE`,
            [planId, userId]
        );
        return result.rows[0] || null;
    } catch (error) {
        console.error('Error fetching plan:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Get pending plans for a conversation
 * @param {number} conversationId - Conversation ID
 * @param {number} userId - User ID for access control
 * @returns {Promise<Array>} List of pending plans
 */
export async function getPendingPlansByConversation(conversationId, userId) {
    try {
        const result = await query(
            `SELECT p.id, p.conversation_id, p.user_message_id, p.plan_json, p.intent_type, 
                    p.status, p.needs_approval, p.created_at
             FROM ChatPlans p
             JOIN Conversations c ON p.conversation_id = c.id
             WHERE p.conversation_id = $1 AND c.user_id = $2 AND p.status = 'pending' 
                   AND p.deleted = FALSE
             ORDER BY p.created_at DESC`,
            [conversationId, userId]
        );
        return result.rows;
    } catch (error) {
        console.error('Error fetching pending plans:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Approve a plan
 * @param {number} planId - Plan ID
 * @param {number} userId - User ID approving
 * @returns {Promise<Object|null>} Updated plan
 */
export async function approvePlan(planId, userId) {
    try {
        const result = await query(
            `UPDATE ChatPlans
             SET status = 'approved', needs_approval = FALSE, approved_at = $1, 
                 approved_by = $2, updated_by = $2, updated_at = $1
             WHERE id = $3 AND deleted = FALSE
             RETURNING id, status, approved_at, approved_by`,
            [formatTimestamp(), userId, planId]
        );
        return result.rows[0] || null;
    } catch (error) {
        console.error('Error approving plan:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Reject a plan
 * @param {number} planId - Plan ID
 * @param {number} userId - User ID rejecting
 * @param {string} reason - Rejection reason (optional)
 * @returns {Promise<Object|null>} Updated plan
 */
export async function rejectPlan(planId, userId, reason = '') {
    try {
        const result = await query(
            `UPDATE ChatPlans
             SET status = 'rejected', needs_approval = FALSE, rejected_at = $1, 
                 rejected_by = $2, rejection_reason = $3, updated_by = $2, updated_at = $1
             WHERE id = $4 AND deleted = FALSE
             RETURNING id, status, rejected_at, rejection_reason`,
            [formatTimestamp(), userId, reason, planId]
        );
        return result.rows[0] || null;
    } catch (error) {
        console.error('Error rejecting plan:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Update plan status
 * @param {number} planId - Plan ID
 * @param {string} status - New status (pending, approved, executing, executed, failed, etc.)
 * @param {number} userId - User ID
 * @returns {Promise<Object|null>} Updated plan
 */
export async function updatePlanStatus(planId, status, userId) {
    try {
        const result = await query(
            `UPDATE ChatPlans
             SET status = $1, updated_by = $2, updated_at = $3
             WHERE id = $4 AND deleted = FALSE
             RETURNING id, status, updated_at`,
            [status, userId, formatTimestamp(), planId]
        );
        return result.rows[0] || null;
    } catch (error) {
        console.error('Error updating plan status:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Get plans by conversation ID
 * @param {number} conversationId - Conversation ID
 * @param {number} userId - User ID for access control
 * @param {number} limit - Limit results
 * @returns {Promise<Array>} List of plans
 */
export async function getPlansByConversation(conversationId, userId, limit = 50) {
    try {
        const result = await query(
            `SELECT p.id, p.conversation_id, p.plan_json, p.intent_type, p.status, 
                    p.needs_approval, p.created_at, p.updated_at
             FROM ChatPlans p
             JOIN Conversations c ON p.conversation_id = c.id
             WHERE p.conversation_id = $1 AND c.user_id = $2 AND p.deleted = FALSE
             ORDER BY p.created_at DESC
             LIMIT $3`,
            [conversationId, userId, limit]
        );
        return result.rows;
    } catch (error) {
        console.error('Error fetching plans:', error);
        throw new Error(sanitizeDbError(error));
    }
}

/**
 * Soft delete plan
 * @param {number} planId - Plan ID
 * @param {number} userId - User ID
 * @returns {Promise<boolean>} Success status
 */
export async function deletePlan(planId, userId) {
    try {
        const result = await query(
            `UPDATE ChatPlans
             SET deleted = TRUE, updated_by = $1, updated_at = $2
             WHERE id = $3
             RETURNING id`,
            [userId, formatTimestamp(), planId]
        );
        return result.rows.length > 0;
    } catch (error) {
        console.error('Error deleting plan:', error);
        throw new Error(sanitizeDbError(error));
    }
}
